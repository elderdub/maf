<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="author" content="//github.com/elderdub" />
		<meta name="illustration" content="//derekq-art.tumblr.com" />
		<meta name="version" content="0.12" />
		<meta name="description" content="Licensed under the GNU AGPL License 3.0 - //www.gnu.org/licenses/agpl.html" />
		<title>Mafia Administrative Utility for Offline Gaming</title>
							
		<style>
body {
	background-color: #212C21;
	background-image: url('./maf_bg.png');
	background-attachment: fixed;
}

body, input, select, textarea, button {
	box-sizing: border-box;
	color: goldenrod;
	font: 12pt 'Trebuchet MS', Tahoma, Generic;
	letter-spacing: .025em;
	line-height: 1.45em;
}
body.vh , .vh input, .vh select, .vh textarea, .vh button {
	font-size: 1.4vh;
}
h1, h2, h3, h4, h5, h6 { font-weight: normal }
h2 { text-align: center; font-size: 1.5em }
.round-start { transform: scale(5) }
div { position: relative }
input { background-color: dimgrey; color: gainsboro; border: lightgrey 1px solid; border-radius: 2px }
.vh input { border-width: .125vh; border-radius: .25vh }
input[type="number"] { width: 64px }
.vh input { width: 8vh }

.error-field { background-color: #CD5C5C44; border-color: firebrick; color: firebrick }

button { background-color: royalblue; color: white; border: none; border-radius: 4px 0; padding: 8px 0; font-size: .8em }
.vh button { border-radius: .5vh 0; padding: 1vh 0; }
button:active { background-color: #3159D1; color: #FFFA; transform: scale(.96) }
button.without { background-color: slategrey; color: #FFF8 }
button.without:active { background-color: #607080; color: #FFF4 }
button.start, button.next { background-color: forestgreen }
button.start:active, button.next:active { background-color: #127B12 }
button.back { background-color: darkgoldenrod }
button.active { background-color: firebrick }
button.active:active { background-color: #A21212 }
button[disabled], button[disabled]:active { background-color: dimgrey; opacity: .45; transform: none }

body > div, .speak-timer { width: 560px; margin: 0 auto; background-color: #212C21AA; border-radius: 20px }
body.vh > div, .speak-timer { width: 70vh; border-radius: 5vh }
body > div:nth-child(n+2) { margin-top: 10px }
body.vh > div:nth-child(n+2) { margin-top: 1.25vh }
.controls { display: flex; flex-direction: column; row-gap: 10px; flex-grow: 1 }
.vh .controls { row-gap: 1.25vh }
.controls > div { display: flex; column-gap: 10px; align-items: center; justify-content: flex-start; flex-grow: 1 }
.vh .controls > div { column-gap: 1.25vh }
.controls button, body > .bottom-controls button { width: 132px }

.controls > .turn { justify-content: center; flex-wrap: wrap; row-gap: 10px }
.vh .controls > .turn { row-gap: 1.25vh }
.vh .controls button { width: 16.5vh }
.controls .turn button { width: 108px }
.vh .controls .turn button { width: 13.5vh }

.controls button.start, .controls button.next { margin-left: auto }
.controls button.back { margin-right: auto }
.desk { width: 560px; height: 560px }
.vh .desk { width: 65vh; height: 65vh }
.desk:after {
	position: absolute;
	top: 12%;
	left: 33%;
	width: 34%;
	height: 76%;
	border-radius: 60%;
	border: #000A 1px solid;
	background-image: radial-gradient(#0002, #0006);
	content: '';
}
.vh .desk:after { border-width: .125vh }
.desk > .player { position: absolute; margin: -4% 0 0 -4%; width: 7%; height: 7%; font-size: 1.8em; color: royalblue; font-weight: bold;
	text-shadow: 0 0 4px black; z-index: 1; border-radius: 4px; padding: 1% }
.vh .desk > .player { text-shadow: 0 0 1vh black }
.desk > .player:after, .desk > .player:before { position: absolute; left: 25%; top: 35%; font-size: 2em; opacity: .67; z-index: -1 }
.desk > .player:before { z-index: 1 }

body.revealing > .desk > .player { opacity: .1 }
body.revealing > .desk > .player.revealing { background-color: #8888; opacity: 1; font-size: 14em; top: 0 !important; left: 0 !important; z-index: 2;
	width: 100%; height: 100%; border-radius: .25em }
body.revealing > .desk > .player.revealing:after, .desk > .player.revealing:before { opacity: 1 }
body.revealing > .desk > .player.revealing:after { left: .25em }
body.revealing > .desk > .player.revealing:before { color: firebrick; content: '♥'; left: 1em }

body.revealing > .desk > .player.maf.revealing:before,
body.revealing > .desk > .player.don.revealing:before,
body.revealing > .desk > .player.maniac.revealing.mafs-defeated:before { color: black; content: '♠' }

.player:after { content: '👶'; }
.chair:after { content: '🪑'; }
.chair:hover { background-color: #FF02 }
.chair:hover:after { opacity: .9 }
.hidden { display: none }
/*
.player.maniac.revealing:not(.mafs-defeated):after { content: '👶' }
*/
.player.maniac.revealing:after,
.player.whore.revealing:after,
.player.doctor.revealing.by-don:after { content: '👶' }

.doctor:after { content: '👨‍⚕️' }

.maf:after { content: '🥷' }
/*
.maf:after { content: '👺' }
*/
.don:after { content: '👑' }
.maniac:after { content: '🧟‍♂️' }
.whore:after { content: '💃' }
.sheriff:after { content: '👮‍♂️' }

.player.active { border: yellowgreen 3px solid }
.vh .player.active { border-width: .38vh }
.player.active:after { opacity: 1 }

.desk > .player.inactive { color: dimgrey }
.desk > .player.inactive:after { filter: grayscale(1); font-size: 1em }
.jailed:before { content: '⛓️' }
/*
.killed:before { content: '❌' }
*/
.killed:before { content: '🪦' }
.voted:before { content: '❓' }
.voted.current:before { animation: scale 2s infinite }
.slut-protected:before { content: '🛡️' }
.med-protected:before { content: '💊' }

.roleset { position: absolute; display: flex; column-gap: 10px; background-color: dimgrey; border-radius: 10px; padding: 10px; font-size: 1.8em; z-index: 1 }
.vh .roleset { column-gap: 1.25vh; border-radius: 1.25vh; padding: 1.25vh }
.roleset > div { font-size: 2em }
body > .bottom-controls { background-color: transparent; text-align: center }
body > .bottom-controls button { width: 176px }
body.vh > .bottom-controls button { width: 22vh }

.desk > .player.killed.hidden-role:not(.inactive):before,
.desk > .player.slut-protected.hidden-role:before,
.desk > .player.med-protected.hidden-role:before { display: none }

.desk > .player.hidden-role:after { content: '🦝' }

.reset { position: fixed; bottom: 8px; right: 8px; font-size: 3.6em; width: 80px; height: 80px }
.vh .reset { bottom: 1vh; right: 1vh; width: 10vh; height: 10vh }
.reset:after { content: '🔄' }

.half-a-minute-speech { border: firebrick 3px solid }
.votes, .controls > div.speak-timer { position: absolute; font-size: 3.6em; z-index: 1; }
.votes input, .vh .votes input { font-size: 1em; width: 96px; opacity: .67 }
.votes input:focus { opacity: 1 }
.votes { margin-top: -4% }
.vh .votes input { width: 12vh }
.controls, .reset, .controls > div.speak-timer { display: flex; align-items: center; justify-content: center }
.controls > div.speak-timer { top: 0; left: 0; height: 100%; color: whitesmoke; border: forestgreen 3px solid }
.vh .controls > div.speak-timer { border-width: .38vh }
.controls > div.speak-timer.hurry-up { background-color: #B8860B88; border-color: darkgoldenrod }
.controls > div.speak-timer.exceed { background-color: #A2121288; border-color: firebrick }

button, .chair:after { transition: .75s }
.chair { transition: background-color .3s, border-color .3s, font-size 1s, width 1s, height 1s }
h2 { transition: transform .3s linear}
@keyframes scale { 0% { transform: scale(1) } 50% { transform: scale(2) } 100% { transform: scale(1) } }
		</style>
	<script>
(function() {
	function TM_MAF(params) {
		this.secondsToMilliseconds = 1000;
		//this.secondsToMilliseconds = 10;
		if(params) {
			Object.entries(params).forEach(( [ k, v ] ) => {
				this[k] = v;
			});
		}
		if(!this.initialized && typeof this.init == 'function') {
			this.init(this);
		}
		return this;
	}
	Object.entries({
		chairDrag: function(e) {
			if(this.drag.chair) {
				const rangeLeft = { min: 0, max: this.drag.width };
				const rangeTop = { min: 0, max: this.drag.height };
				const left = Math.max(rangeLeft.min, Math.min(this.drag.start.left - this.drag.clientX + e.clientX, this.drag.width));
				const top = Math.max(rangeTop.min, Math.min(this.drag.start.top - this.drag.clientY + e.clientY, this.drag.height));
				this.drag.chair.style.left = (left * 100 / this.drag.width).toFixed(2) + '%';
				this.drag.chair.style.top = (top * 100 / this.drag.height).toFixed(2) + '%';
			}
		},
		chairGrab: function(e) {
			const target = e.target.closest('.chair');
			if(!target) {
				return;
			}
			this.drag = {
				chair: target,
				clientX: e.clientX,
				clientY: e.clientY,
				touched: e.type == 'touchstart',
				start: {
					left: this.desk.offsetWidth / 100 * target.style.left.replace(/%/, ''),
					top: this.desk.offsetHeight / 100 * target.style.top.replace(/%/, '')
				},
				width: this.desk.offsetWidth,
				height: this.desk.offsetHeight
			}
			if(this.drag.touched) {
				window.addEventListener('touchmove', e => {
					this.chairTouchDrag(e);
				});
				window.addEventListener('touchend', e => {
					this.chairRelease(e);
				});
			} else {
				window.addEventListener('mousemove', e => {
					this.chairDrag(e);
				});
				window.addEventListener('mouseup', e => {
					this.chairRelease(e);
				});
			}
			this.drag.chair.classList.add('active');
		},
		chairRelease: function(e) {
			if(this.drag.touched) {
				window.removeEventListener('touchmove', e => {
					this.chairTouchDrag(e);
				});
				window.removeEventListener('touchend', e => {
					this.chairRelease(e);
				});
				
			} else {
				window.removeEventListener('mousemove', e => {
					this.chairDrag(e);
				});
				window.removeEventListener('mouseup', e => {
					this.chairRelease(e);
				});
			}
			if(this.drag.chair) {
				this.drag.chair.classList.remove('active');
				const top = Math.round(parseFloat(this.drag.chair.style.top.replace(/%/, '')));
				const left = Math.round(parseFloat(this.drag.chair.style.left.replace(/%/, '')));
				this.drag.chair.style.top = top + '%';
				this.drag.chair.style.left = left + '%';
				const chairId = this.getNumber(this.drag.chair);
				this.cfg.pos[chairId] = top + '/' + left;
				this.saveCfg();
				this.makeIfNew('div', 'bottom-controls reset-chairs', '<button>' + this.L.resetPositions + '</button>');
			}
			this.drag = {};
		},
		chairTouchDrag: function(e) {
			e.clientX = e.touches[0].clientX;
			e.clientY = e.touches[0].clientY;
			this.chairDrag(e);
		},
		clickHandler: function(e) {
//console.log(e.target);
			const nextButton = this.el(this.controls, '.next');
			const isMidnight = nextButton && nextButton.innerHTML == this.L.startDay;
			const isRepeatedDebate = this.el(this.controls, 'h2').innerHTML == this.L.repeatedDebate;
			const isVoteStarted = nextButton && nextButton.innerHTML == this.L.voteFinish;
			const roundNumber = this.cfg.stat.length - 1;

			if(document.body.classList.contains('revealing')) {
				this.els('.revealing').forEach(unreveal => unreveal.classList.remove('revealing', 'by-don', 'mafs-defeated'));
				if(!this.cfg.rh) {
					this.els('.player').forEach(unhide => unhide.classList.remove('hidden-role'));
				} else {
					this.els('.player').forEach(hide => hide.classList.add('hidden-role'));
				}
				return;
			}

			// close speech timer and proceed to next speaker, if any
			const speakTimer = e.target.closest('.speak-timer');
			if(speakTimer) {
				speakTimer.remove();
				if(this.votedLeft && this.votedLeft.length) {
					this.el(this.desk, '.chair' + this.votedLeft.shift()).classList.remove('active');
					if(this.votedLeft.length) {
						this.el(this.desk, '.chair' + this.votedLeft[0]).classList.add('active');
						return null;
					} else {
						return this.stageRoundVoteInit();
					}
				} else if(!this.cfg.cs && this.killedToday && this.killedToday.length) {
					this.el(this.desk, '.chair' + this.killedToday.shift()).classList.remove('half-a-minute-speech');
					if(this.killedToday.length) {
						this.el(this.desk, '.chair' + this.killedToday[0]).classList.add('half-a-minute-speech');
					}
				}
				return (!this.votedLeft || !this.votedLeft.length) && (!this.killedToday || !this.killedToday.length) && !isMidnight
					? this.detectNextSpeaker()
					: null;
			}

			const resetAllButton = e.target.closest('.reset');
			if(resetAllButton) {
				if(confirm(this.L.resetAll)) {
					this.cfg.stat = [];
					this.els('.hide-roles, .turn').forEach(removeControls => removeControls.remove());
					[ 'midnightTurn', 'roleDefining', 'turn', 'votedLeft', 'voteOrder'].forEach(deleteStorage => {
						if(this[deleteStorage]) {
							delete this[deleteStorage];
						}
					});
					this.saveState();
					this.stageConfigure();
				}
				return;
			}

			const controlsButton = e.target.closest('.controls button');
			if(controlsButton) {
				if(!this.cfg.stat || !this.cfg.stat.length) {
					if(controlsButton.classList.contains('start')) {

						// finish "Configuration" and proceed to "Define Roles" stage
						return this.stageDefineRoles();
					}
					controlsButton.classList.toggle('without');
					const itemType = controlsButton.className.replace(/ without$|^without /, '');
					const without = controlsButton.classList.contains('without');
					controlsButton.innerHTML = this.L[(without ? 'without' : 'with') + itemType.charAt(0).toUpperCase() + itemType.substr(1)];

					if(itemType == 'doctor') {
						this.cfg[this.cookCodes[itemType]] = without ? 1 : '';
					} else {
						this.cfg[this.cookCodes[itemType]] = !without ? 1 : '';
					}
					if(this.cfg[this.cookCodes[itemType]]) {

						// save game "with/without" term
						this.setCookie(this.cookCodes[itemType], this.cfg[this.cookCodes[itemType]]);
					} else {
						this.removeCookie(this.cookCodes[itemType]);
					}
					return (without ? 'without' : 'with') + ' ' + itemType;
				}

				// return from "Define Roles" to "Configuration" stage
				if(this.cfg.stat.length == 1) {
					if(controlsButton.classList.contains('back')) {
						this.cfg.stat = [];
						return this.stageConfigure();
					}
					if(controlsButton.classList.contains('next')) {
						return this.stageRoundInit(true);// create a new round
					}
					return;
				}

				// control Round cases
				if(this.cfg.stat.length > 1) {
					if(controlsButton.parentNode.classList.contains('turn')) {
						return this.stageRoundMidnight(controlsButton);
					}
				}
				if(controlsButton.classList.contains('next')) {

					// start daylight mode
					if(isMidnight) {

						// whore brings one to death
						var deadWhore = this.el(this.desk, '.killed.whore');
						const slutProtected = this.el(this.desk, '.slut-protected');
						if(deadWhore) {

							// doctor saves a whore special case
							if(deadWhore.classList.contains('med-protected')) {
								deadWhore = null;
							} else if(slutProtected) {
								this.playerOut('killed', slutProtected, roundNumber);
							}
						}

						// count killed today
						this.killedToday = [];
						Object.values(this.els(this.desk, '.killed')).filter(killed => {
							return !killed.classList.contains('inactive');
						}).forEach(killed => {

							// doctor saves a life
							if(killed.classList.contains('med-protected')) {
								this.playerOut('unkill', killed, roundNumber);

							// whore saves a life
							} else if(killed.classList.contains('slut-protected') && !deadWhore) {
								this.playerOut('unkill', killed, roundNumber);
							} else {
								killed.classList.add('inactive');
								this.killedToday.push(this.getNumber(killed));
							}
						});

						this.els(this.desk, '.player').forEach(player => player.classList.remove('slut-protected', 'med-protected'));
						if(this.killedToday.length) {
							this.el(this.desk, '.chair' + this.killedToday[0]).classList.add('half-a-minute-speech');
						} else {

							// highlight next speaker
							var nextPlayerNumber = this.detectNextSpeaker();
						}

						// set next button to "start vote" and disable it
						this.els(this.turn, '.action').forEach(removeActionButton => removeActionButton.remove());
						
						//unset unfinished midnight turn
						if(this.midnightTurn) {
							delete this.midnightTurn;// on start day
						}
						controlsButton.innerHTML = this.L.voteStart;
						controlsButton.disabled = true;
						return this.validateGame();
					}

					// vote start
					if(controlsButton.innerHTML == this.L.voteStart) {
						return this.stageRoundVoteInit();
					}

					// vote finish
					if(controlsButton.innerHTML == this.L.voteFinish) {
						const voteRaw = {};
						var voteError = false;
						this.els(this.desk, '.votes').forEach(votes => {
							const voteInput = votes.querySelector('input');
							const voteNum = voteInput.value;
							if(!voteNum.length) {
								voteInput.classList.add('error-field');
								voteInput.addEventListener('focus', function(e) {
									if(e.target.classList.contains('error-field')){
										e.target.classList.remove('error-field');
									}
								});
								voteError = true;
								return;
							}
							if(!voteRaw[voteNum]) {
								voteRaw[voteNum] = [];
							}
							voteRaw[voteNum].push(this.getNumber(votes));
						});
						if(voteError) {
							return;
						}
						const voteSorted = Object.entries(voteRaw).sort((a, b) => b[0] - a[0]);
						if(!voteSorted[0] || voteSorted[0][0] == 0) {
							return this.stageRoundInit(true);// create a new round
						}
						if(voteSorted[0][1].length == 1) {

							// "killed today" are "morning speakers" also
							this.killedToday = [ voteSorted[0][1][0] ];
							const player = this.el(this.desk, '.chair' + voteSorted[0][1][0]);
							player.classList.add('inactive', 'half-a-minute-speech');
							this.playerOut('jailed', player, roundNumber);
							return this.stageRoundInit(true);// create a new round
						}

						// "repeated vote" mode, "still equal vote numbers" case
						if(voteSorted.length == 1 && 'votedLeft' in this) {
							this.nav.innerHTML = [ this.L.jailNone, this.L.jailAll ].map(button => {
								return '<button class="next">' + button + '</button>';
							}).join('');
							return;
						}

						this.votedLeft = voteSorted[0][1];
						return this.stageRoundVoteSpeech();
					}

					// repeated vote finish
					if([ this.L.jailNone, this.L.jailAll ].includes(controlsButton.innerHTML)) {
						const jailAll = controlsButton.innerHTML == this.L.jailAll;
						this.killedToday = [];
						this.els(this.desk, '.voted').forEach(removeVoted => {
							removeVoted.classList.remove('voted');
							if(jailAll) {
								this.playerOut('jailed', removeVoted, roundNumber);
								removeVoted.classList.add('inactive');
								if(!this.killedToday.length) {
									removeVoted.classList.add('half-a-minute-speech');
								}
								this.killedToday.push(this.getNumber(removeVoted));
							}
						});
						return this.stageRoundInit(true);// create a new round
					}
				}
			}

			const playerButton = e.target.closest('.desk > .player');
			if(playerButton) {
				const chairId = this.getNumber(playerButton);

				// open "Set of Roles" menu on "Define Roles" stage
				if(this.cfg.stat.length == 1) {
					if(!('roleDefining' in this)) {
						return this.stageEnableRoleSet(chairId);
					}
					return;
				}

				// Round
				if(this.cfg.stat.length) {

					// killed player button click
					if(playerButton.classList.contains('half-a-minute-speech')) {
						return this.speakFor(30, playerButton);
					}
					if(playerButton.classList.contains('active')) {
						return this.speakFor(60, playerButton);
					}

					// player button click
					if(!playerButton.classList.contains('inactive')) {
						if(this.midnightTurn) {
							if(playerButton.classList.contains('voted')) {
								playerButton.classList.remove('voted');
							}

							// killing a player
							if(['maf', 'maniac'].includes(this.midnightTurn)) {
								Object.values(this.els(this.desk, '.killed')).filter(killed => {
									return !killed.classList.contains('inactive');
								}).forEach(killed => {
									this.playerOut('unkill', killed, roundNumber);
								});
								this.playerOut('killed', playerButton, roundNumber);

							// healing a player
							} else if([ 'doctor' ].includes(this.midnightTurn)) {
								this.els('.med-protected').forEach(unprotect => unprotect.classList.remove('med-protected'));
								playerButton.classList.add('med-protected');

							// revealing a player
							} else if([ 'don', 'sheriff' ].includes(this.midnightTurn)) {
								this.els('.player').forEach(temporarilyHide => temporarilyHide.classList.add('hidden-role'));
								playerButton.classList.add('revealing');
								if(this.midnightTurn == 'don') {
									playerButton.classList.add('by-don');
								} else if(this.midnightTurn == 'sheriff') {
									if(!Object.values(this.els(this.desk, '.maf, .don')).filter(maf => {
										return !maf.classList.contains('inactive')
									}).length) {
										playerButton.classList.add('mafs-defeated');
									}
								}
								playerButton.classList.remove('hidden-role');
								document.body.classList.add('revealing');

							// slut-protecting a player
							} else if([ 'whore' ].includes(this.midnightTurn)) {
								this.els('.slut-protected').forEach(unprotect => unprotect.classList.remove('slut-protected'));
								playerButton.classList.add('slut-protected');
							}
							this.el(this.controls, '.' + this.midnightTurn).classList.remove('active');
							delete this.midnightTurn;// on applying current midnight turn
						
						// daylight mode - set voted status
						} else if(!isMidnight && !isRepeatedDebate && !isVoteStarted) {
							playerButton.classList.toggle('voted');
							if(playerButton.classList.contains('voted')) {
								if(!this.voteOrder) {
									this.voteOrder = [];
								}
								this.voteOrder.push(chairId);
							} else if(this.voteOrder) {
								const removeVoteIndex = this.voteOrder.findIndex(voted => voted == chairId);
								if(removeVoteIndex !== -1) {
									this.voteOrder.splice(removeVoteIndex, 1);
								}
							}
						}
					}
				}
				return;
			}

			// stageEngageRole
			const roleButton = e.target.closest('.role');
			if(roleButton) {
				return this.stageEngageRole(roleButton.className.replace(/^role /, ''));
			}

			const hideRolesButton = e.target.closest('.hide-roles button');
			if(hideRolesButton) {
				this.showHideRoles(true);// set show/hide state
			}

			const resetChairsButton = e.target.closest('.reset-chairs button');
			if(resetChairsButton) {
				resetChairsButton.parentNode.remove();
				return this.stageConfigChairs(true);// reset custom chair position
			}
		},
		detectNextSpeaker: function() {
			const hasPreviousSpeaker = this.cfg.cs;
			var nextPlayerNumber = hasPreviousSpeaker
				? this.cfg.cs + 1
				: this.cfg.stat.length - 1;
			if(hasPreviousSpeaker) {
				this.el(this.desk, '.chair' + this.cfg.cs).classList.remove('active');
			}
			var nextPlayer = this.el(this.desk, '.chair' + nextPlayerNumber);

			for(var i = 1; i < this.cfg.pl && (!nextPlayer || nextPlayer.classList.contains('inactive')); ++i) {
				++nextPlayerNumber;
				if(this.cfg.fs && nextPlayerNumber == this.cfg.fs) {
					break;
				}
				nextPlayer = this.el(this.desk, '.chair' + nextPlayerNumber);
				if(!nextPlayer) {
					nextPlayerNumber = 1;
					nextPlayer = this.el(this.desk, '.chair' + nextPlayerNumber);
				}
			}
			if(this.cfg.fs && nextPlayerNumber == this.cfg.fs) {
				nextPlayer = null;
			}
			if(nextPlayer && !nextPlayer.classList.contains('inactive')) {
				nextPlayer.classList.add('active');
			}
			if(!nextPlayer) {
				this.el(this.controls, '.next').disabled = false;
				return null;
			} else {
				return nextPlayerNumber;
			}
		},
		el: function(container, querySelector) {
			if(!(container instanceof HTMLElement)) {
				querySelector = container;
				container = document;
			}
			return container.querySelector(querySelector);
		},
		els: function(container, querySelector) {
			if(!(container instanceof HTMLElement)) {
				querySelector = container;
				container = document;
			}
			return container.querySelectorAll(querySelector);
		},
		getNumber: function(playerButton) {
			return parseInt(playerButton.className.replace(/\D+/g, ''));
		},
		i18n: {
			en: {},
			ru: {
				gameConfiguration: 'Подготовка к игре',
				back: 'Назад',
				displayRoles: 'Показать роли',
				hideRoles: 'Скрыть роли',
				jailAll: 'Удалить всех',
				jailNone: 'Не удалять никого',
				next: 'Продолжить',
				playersCount: 'Количество игроков',
				playersDefine: 'Определение игроков',
				resetAll: 'Вы действительно хотите сбросить прогресс?',
				round: 'Раунд',
				start: 'Начать',
				repeatedDebate: 'Повторные прения',
				resetPositions: 'Сбросить расположение',
				startDay: 'Начать день',
				turnDoctor: 'Ход доктора',
				turnDon: 'Ход дона',
				turnMaf: 'Ход мафии',
				turnManiac: 'Ход маньяка',
				turnSheriff: 'Ход шерифа',
				turnWhore: 'Ход проститутки',
				voteFinish: 'Голосовать',
				voteStart: 'Начать голосование',
				winMaf: 'Игра завершена. Победила Мафия.',
				winManiac: 'Игра заершилась победой Маньяка.',
				winWorld: 'Игра заершена. Город победил.',
				withDoctor: 'С доктором',
				withDon: 'С доном',
				withManiac: 'С маньяком',
				withWhore: 'С проституткой',
				withoutDoctor: 'Без доктора',
				withoutDon: 'Без дона',
				withoutManiac: 'Без маньяка',
				withoutWhore: 'Без проститутки'
			}
		},
		init: function() {
			this.L = this.i18n[this.lang || 'ru'];
			this.cfg = { stat: [] };
			this.hasTouchstart = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
			document.cookie.split(/; */).forEach(cook => {
				cook = cook.split('=');
				const name = cook.shift();
				if(name.indexOf('maf_') !== 0) {
					return;
				}
				cook = cook.join('=');
				try {
					this.cfg[name.substr(4)] = cook.length && [ '[', '{' ].includes(cook.charAt(0)) ? JSON.parse(cook) : cook;
				} catch(e) {
					this.cfg[name.substr(4)] = cook;
				}
			});
			document.body.addEventListener('click', e => {
				this.clickHandler(e);
			});
			this.makeIfNew('div', 'reset');
			this.initialized = true;
			this.stageConfigure();
		},
		listExistingRoles: function() {
			const roles = [ 'player', 'sheriff', 'maf' ];
			Object.entries(this.cookCodes).forEach(( [ inCss, inCfg ] ) => {
				if((inCfg == 'noDoc' && !this.cfg[inCfg])
				|| (inCfg != 'noDoc' && this.cfg[inCfg])) {
					roles.push(inCss);
				}
			});
			return roles;
		},
		make: function(tagName, className, innerHTML, attrs) {
			const el = document.createElement(tagName);
			if(className) {
				el.className = className;
			}
			if(innerHTML) {
				el.innerHTML = innerHTML;
			}
			if(attrs) {
				Object.entries(attrs).forEach(( [ k, v ] ) => el.setAttribute(k, v));
			}
			return el;
		},
		makeIfNew: function(container, tagName, className, innerHTML) {
			if(container === null) {
			} else if(!(container instanceof HTMLElement)) {
				innerHTML = className;
				className = tagName;
				tagName = container;
				container = document.body;
			}
			const existingEl = this.el(container || document.body, '.' + className.replace(/ /g, '.'));
			const el = existingEl || this.make(tagName, className, innerHTML);
			if(!existingEl) {
				if(container) {
					container.appendChild(el);
				}
			}
			if(innerHTML) {
				el.innerHTML = innerHTML;
			}
			return el;
		},
		numbertoRoman: function(n) {
			var r = '';
			const decimals = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];
			const roman = [ 'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I' ];
			for(var i = 0; i < decimals.length; i++) {
				while(n >= decimals[i]) {
					r += roman[i];
					n -= decimals[i];
				}
			}
			return r;
		},
		playerOut: function(className, player, roundNumber) {
			if(!roundNumber) {
				roundNumber = this.cfg.stat.length - 1;
			}
			const chairId = this.getNumber(player);
			if(className == 'unkill') {
				player.classList.remove('killed');
				this.cfg.stat[roundNumber].k.splice(this.cfg.stat[roundNumber].k.findIndex(v => v == chairId), 1);
				return this.saveState();
			}
			player.classList.add(className);
			const k = className.charAt(0);
			if(!this.cfg.stat[roundNumber][k]) {
				this.cfg.stat[roundNumber][k] = [];
			}
			this.cfg.stat[roundNumber][k].push(chairId);
			return this.saveState();
		},
		removeCookie: function(name) {
			document.cookie = 'maf_' + name + '=; expires=' + new Date(0).toUTCString() + '; samesite=strict';
		},
		saveCfg: function() {
			Object.entries(this.cfg).forEach(( [ k, v ] ) => {
				const stringified = typeof v == 'object' ? JSON.stringify(v) : null;
				if(typeof v == 'object' && [ '[]', '{}' ].includes(JSON.stringify(v))) {
					this.removeCookie(k);
				}
				else {
					this.setCookie(k, stringified || v);
				}
			});
		},
		saveState: function() {
			this.setCookie('stat', JSON.stringify(this.cfg.stat));
		},
		setCookie: function(name, value) {
			document.cookie = 'maf_' + name + '=' + value + '; expires=' + new Date(Date.now() + 365 * 86400000).toUTCString() + '; samesite=strict';
		},
		showHideRoles: function(setState) {
			const hide = setState ? !this.cfg.rh : this.cfg.rh;
			this.hideRolesButton = this.makeIfNew('div', 'bottom-controls hide-roles', '<button>' + (hide ? this.L.displayRoles : this.L.hideRoles) + '</button>');
			if(hide) {
				this.els(this.desk, '.player').forEach(hideRole => hideRole.classList.add('hidden-role'));
				if(setState) {
					this.cfg.rh = true;// rh = roles hidden
					this.setCookie('rh', 1);
				}
			} else {
				this.els(this.desk, '.player').forEach(displayRole => displayRole.classList.remove('hidden-role'));
				if(setState) {
					delete this.cfg.rh;
					this.removeCookie('rh');
				}
			}
		},
		speakFor: function(e, playerButton) {
			const sec = typeof e == 'number' ? e : e.sec;
			const speechInProgress = this.el(this.controls, '.speak-timer');
			const chairId = e && typeof e == 'object' && 'chairId' in e
				? e.chairId
				: (playerButton ? this.getNumber(playerButton) : null);

			// timer will not initiate if one exists
			if(speechInProgress && playerButton) {
				return;
			}

			// break the loop on inconsistent "chairId"
			if(speechInProgress && chairId != speechInProgress.dataset.chairId) {
				return;
			}
			if(!speechInProgress) {

				// break the loop on speak-timer close
				if(!playerButton) {
					return;
				}
				if(!playerButton.classList.contains('half-a-minute-speech')) {
					this.cfg.cs = chairId;// cs = current speaker
					this.setCookie('cs', chairId);
					if(!this.cfg.fs) {
						this.cfg.fs = chairId;// fs = first speaker
						this.setCookie('fs', chairId);
					}
				}
			}

			// break the loop on reaching 0:00:00
			if(sec > 0) {
				setTimeout((e) => {
					this.speakFor(e);
				}, 1 * this.secondsToMilliseconds, {
					sec: sec - 1,
					chairId: chairId
				});
			}
			const speakTimer = this.makeIfNew(this.controls, 'div', 'speak-timer');
			speakTimer.dataset.chairId = chairId;
			const d = new Date(sec * 1000);
			const time = [ d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds() ];
			speakTimer.innerHTML = time.map(n => (n < 10 ? '0' : '') + n.toString()).join(':');
			if(sec == 11) {
				speakTimer.classList.add('hurry-up');
			} else if(!sec) {
				speakTimer.classList.remove('hurry-up');
				speakTimer.classList.add('exceed');
			}
		},
		stageConfigure: function() {
			this.cookCodes = {
				don: 'don',
				doctor: 'noDoc',
				maniac: 'mn',
				whore: 'wh'
			};
			const cfg = this.cfg;
			this.controls = this.makeIfNew('div', 'controls', '<h2>' + this.L.gameConfiguration + '</h2>'
				+ '<div>' + this.L.playersCount + '&nbsp;<input type="number" min="0"' + (cfg.pl ? ' value="' + cfg.pl + '"' : '') + ' />'
				+ '<button class="hidden start">' + this.L.start + '</button></div>'
				+ '<div><button class="' + (!cfg.don ? 'without ' : '') + 'don">' + this.L[!cfg.don ? 'withoutDon' : 'withDon'] + '</button>'
				+ '<button class="' + (cfg.noDoc ? 'without ' : '') + 'doctor">' + this.L[cfg.noDoc ? 'withoutDoctor' : 'withDoctor'] + '</button>'
				+ '<button class="' + (!cfg.mn ? 'without ' : '') + 'maniac">' + this.L[!cfg.mn ? 'withoutManiac' : 'withManiac'] + '</button>'
				+ '<button class="' + (!cfg.wh ? 'without ' : '') + 'whore">' + this.L[!cfg.wh ? 'withoutWhore' : 'withWhore'] + '</button>'
				+ '</div>'
			);

			this.el(this.controls, 'input').addEventListener('input', e => {
				const playerNumberInput = e.target.closest('.controls input');
				if(playerNumberInput) {
					if(!playerNumberInput || !playerNumberInput.value || isNaN(playerNumberInput.value)) {
						return;
					}
					this.cfg.pl = parseInt(playerNumberInput.value);

					// save number of players
					this.setCookie('pl', this.cfg.pl);
					return this.stageConfigChairs();
				}
			});

			if(this.stageConfigChairs() && this.cfg.stat.length) {
				this.stageDefineRoles();
			}
		},
		stageConfigChairs: function(resetChairs) {
			if(!this.cfg.pl) {
				return;
			}
			if(resetChairs || !this.cfg.pos) {
				this.cfg.pos = {};
				this.removeCookie('pos');
			}
			const positionedChairs = this.stageConfigChairPosition(this.cfg.pl);
			this.desk = this.makeIfNew('div', 'desk');
			this.els('.player').forEach(removeChair => removeChair.remove());
			positionedChairs.forEach((pos, i) => {
				const chairId = i + 1;
				const chair = this.makeIfNew(this.desk, 'div', 'player chair chair' + chairId, chairId);
				chair.style.cssText = this.cfg.pos[chairId]
					? 'top: ' + this.cfg.pos[chairId].split('/').join('%; left: ') + '%'
					: pos;
				if(this.cfg.pos[chairId]) {
					this.makeIfNew('div', 'bottom-controls reset-chairs', '<button>' + this.L.resetPositions + '</button>');
				}

				// chair drag listener
				if(this.hasTouchstart) {
					chair.addEventListener('touchstart', e => {
						if(!e.target.closest('.chair')) {
							return;
						}
						e.preventDefault();
						this.chairGrab(Object.assign(e, {
							clientX: e.touches[0].clientX,
							clientY: e.touches[0].clientY
						} ));
					});
				}
				chair.addEventListener('mousedown', e => {
					this.chairGrab(e);
				});
			});
			
			if(this.el(this.controls, '.start').classList.contains('hidden')) {
				this.el(this.controls, '.start').classList.remove('hidden');
			}
			return true;
		},
		stageConfigChairPosition: function(playerNumber) {
			if(typeof playerNumber != 'numbre') {
				playerNumber = parseInt(playerNumber);
			}
			const oneOnThinSide = playerNumber%2;
			const perSide = (playerNumber - (oneOnThinSide ? 1 : 2)) / 2;
			const halfSide = perSide / 2;
			const thinSidePos = [
				'top: 95%; left: 50%',
				'top: 5%; left: 50%'
			];
			const topStep = 90 / perSide;
			var initialTop = 90;
			var top = 0;

			return [ ...Array(playerNumber).keys() ].map(i => {
				if(!i) {
					return thinSidePos[0];
				}
				if(i == perSide + 1) {
					top = 0;
					initialTop = 10;
					if(!oneOnThinSide) {
						return thinSidePos[1];
					}
				}
				top = parseFloat((i < perSide + 1
					? (!top ? initialTop : top - topStep)
					: (!top ? initialTop : top + topStep)).toFixed(2));
				return i < perSide + 1
					? 'top: ' + top + '%; left: 25%'
					: 'top: ' + top + '%; left: 75%'
			});
		},
		stageDefineRoles: function() {
			if(!this.cfg.stat.length) {
				this.cfg.stat.push( {} );
			}
			this.saveCfg();
			this.els('.player').forEach(el => {
				el.classList.remove('chair');
				const chairId = this.getNumber(el);
				if(this.cfg.stat[0][chairId]) {
					if(this.cfg.stat[0][chairId] == 'ma') {
						el.classList.add('maf');
					} else if(this.cfg.stat[0][chairId] == 'sh') {
						el.classList.add('sheriff');
					} else {
						el.classList.add(Object.entries(this.cookCodes).find(( [ k, v ] ) => v == this.cfg.stat[0][chairId])[0]);
					}
				}
			});
			this.el(this.controls, 'h2').innerHTML = this.L.playersDefine;
			this.els(this.controls, 'div').forEach(removeDiv => removeDiv.remove());
			this.nav = this.makeIfNew(this.controls, 'div', 'nav', '<button class="back">' + this.L.back + '</button>'
				+ '<button class="next"'
				+ (this.listExistingRoles().filter(role => !this.el(this.desk, '.' + role)).length > 0 ? ' disabled' : '')
				+ '>' + this.L.next + '</button>');

			this.els('.reset-chairs').forEach(removeResetChairsButton => removeResetChairsButton.remove());

			if(this.cfg.stat.length > 1) {

				// roll out players state from saved state
				this.cfg.stat.forEach((stat, i) => {
					if(!i) {
						return;
					}
					[ 'killed', 'jailed' ].forEach(className => {
						const k = className.charAt(0);
						if(!stat[k] || !stat[k].length) {
							return;
						}
						stat[k].forEach(playerNumber => {
							const player = this.el(this.desk, '.chair' + playerNumber);
							player.classList.add(className);
							if(i < this.cfg.stat.length - 1) {
								player.classList.add('inactive');
							}
						});
					});
				});
				this.stageRoundInit();
			}
		},
		stageEnableRoleSet: function(playerNumber) {
			this.roleDefining = playerNumber;
			const chair = this.el('.chair' + playerNumber);
			chair.classList.add('active');
			const roles = this.listExistingRoles();
			const roleset = this.makeIfNew(this.desk, 'div', 'roleset', roles.map(role => '<div class="role ' + role + '"></div>').join(''));
			const chairTop = parseFloat(chair.style.top.replace(/%/, ''));
			roleset.style.cssText = 'top: ' + (chairTop + 8 * (chairTop <= 50 ? 1 : -2)) + '%; left: ' + chair.style.left;
			if(roleset.offsetWidth + roleset.offsetLeft > this.desk.offsetWidth) {
				roleset.style.left = (this.desk.offsetWidth - roleset.offsetWidth) + 'px';
			}
		},
		stageEngageRole: function(role) {
			const roleset = this.el('.roleset');
			const player = this.el('.chair' + this.roleDefining);
			player.className = 'player chair' + this.roleDefining;
			if( [ 'doctor', 'don', 'maniac', 'sheriff', 'whore' ].includes(role)) {
				this.els('.player.' + role).forEach(removeRole => {
					removeRole.classList.remove(role);
					const removeChairId = this.getNumber(removeRole);
					if(removeChairId in this.cfg.stat[0]) {
						delete this.cfg.stat[0][removeChairId];
					}
				});
			}
			const chairId = this.getNumber(player);
			if(role != 'player') {
				player.classList.add(role);
				this.cfg.stat[0][chairId] = this.cookCodes[role] || role.substr(0, 2);
			} else if(this.cfg.stat[0][chairId]) {
				delete this.cfg.stat[0][chairId];
			}

			// save current role configuration
			this.saveState();
			roleset.remove();
			delete this.roleDefining;

			this.el(this.controls, '.next').disabled = this.listExistingRoles().filter(role => !this.el(this.desk, '.' + role)).length > 0;
		},
		stageRoundInit: function(newRound) {

			// clear speakers
			[ 'cs', 'fs' ].forEach(speaker => {
				if(this.cfg[speaker]) {
					delete(this.cfg[speaker]);
					this.removeCookie(speaker);
				}
			});
			if(this.votedLeft) {
				delete(this.votedLeft);
			}

			// remove Back buttons
			this.els(this.controls, '.back').forEach(removeButton => removeButton.remove());

			// remove Votes inputs
			this.els(this.desk, '.votes').forEach(removeVotes => removeVotes.remove());

			// remove voted markers
			this.els(this.desk, '.voted').forEach(removeVoted => removeVoted.classList.remove('voted'));
			if(this.voteOrder) {
				delete this.voteOrder;
			}
			

			// calculate game continue conditions
			if(!this.validateGame()) {
				//return;
			}

			// Midnight mode
			this.nav.innerHTML = '<button class="next">' + this.L.startDay + '</button>';
			const actionRoles = [ 'maf', 'sheriff' ];
			Object.entries(this.cookCodes).forEach(( [ inCss, inCfg ] ) => {
				if((inCfg == 'noDoc' && !this.cfg[inCfg])
				|| (inCfg != 'noDoc' && this.cfg[inCfg])) {
					actionRoles.push(inCss);
				}
			});
			const newRoundNumber = this.cfg.stat.length - (newRound ? 0 : 1);
			const h2 = this.el(this.controls, 'h2');
			h2.innerHTML = this.L.round + ' ' + this.numbertoRoman(newRoundNumber);

			if(newRound) {
				this.cfg.stat.push( {} );
				h2.classList.add('round-start');
				setTimeout(function(h2) {
					h2.classList.remove('round-start');
				}, 1500, h2);
			}

			// save newly started round
			this.saveState();
			
			const turnInit = !this.turn;
			const turn = this.makeIfNew(null, 'div', 'turn', actionRoles.sort((a, b) => {
				return [ 'doctor', 'sheriff' ].includes(a)
					? 1
					: ([ 'don', 'whore' ].includes(b) ? 1 : 0);
			}).map(role => '<button class="' + role + ' action">'
				+ this.L['turn' + role.charAt(0).toUpperCase() + role.substr(1)] + '</button>').join(''));
			if(turnInit) {
				this.turn = turn;
				this.controls.insertBefore(turn, this.nav);
				this.showHideRoles();
			}
		},
		stageRoundMidnight: function(controlsButton) {
			if(!controlsButton.classList.contains('active')) {
				this.els(this.controls, '.active').forEach(inactivate => inactivate.classList.remove('active'));
			}
			controlsButton.classList.toggle('active');
			if(controlsButton.classList.contains('active')) {
				this.midnightTurn = controlsButton.className.replace(/ .+$/, '');
			} else if(this.midnightTurn) {
				delete this.midnightTurn;// on cancelling current midnight turn
			}
		},
		stageRoundVoteInit: function() {
			const votedCollection = this.els(this.desk, '.voted');
			if(!votedCollection.length) {
				return this.stageRoundInit(true);// create a new round
			}
			votedCollection.forEach(voted => {
				if(voted.classList.contains('active')) {
					voted.classList.remove('active');
				}
				const votes = this.makeIfNew(this.desk, 'div', 'votes votes' + this.getNumber(voted), '<input type="number" min="0" />');
				votes.style.cssText = 'top: ' + voted.style.top + '; left: ' + (parseFloat(voted.style.left.replace(/%/, '')) + 8) + '%';
			});

			// preserve vote order
			if(this.voteOrder && this.voteOrder.length) {
				this.els(this.desk, '.votes input').forEach(votesInput => votesInput.addEventListener('input', e => {
					const chairId = this.getNumber(e.target.parentNode);
					const player = this.el(this.desk, '.chair' + chairId);
					const removeVoteIndex = this.voteOrder.findIndex(voted => voted == chairId);
					if(removeVoteIndex !== -1) {
						this.voteOrder.splice(removeVoteIndex, 1);
					}
					if(player.classList.contains('current')) {
						player.classList.remove('current');
					}
					if(this.voteOrder.length) {
						this.el(this.desk, '.chair' + this.voteOrder[0]).classList.add('current');
					}
				}));
				this.el(this.desk, '.chair' + this.voteOrder[0]).classList.add('current');
			}
			this.el(this.controls, '.next').innerHTML = this.L.voteFinish;
		},
		stageRoundVoteSpeech: function() {
			if(!this.votedLeft || !this.votedLeft.length) {
				return;
			}
			this.els(this.desk, '.votes').forEach(removeVotes => removeVotes.remove());
			Object.values(this.els(this.desk, '.voted')).filter(voted => {
				return !this.votedLeft.includes(this.getNumber(voted));
			}).forEach(unvoted => unvoted.classList.remove('voted'));
			this.el(this.controls, '.next').innerHTML = this.L.voteStart;
			this.el(this.controls, 'h2').innerHTML = this.L.repeatedDebate;
			this.el(this.desk, '.chair' + this.votedLeft[0]).classList.add('active');
		},
		validateGame: function() {
			const game = { world: 0, maf: 0, maniac: 0 };
			Object.values(this.els(this.desk, '.player')).filter(player => {
				return !player.classList.contains('inactive');
			}).forEach(player => {
				if(player.classList.contains('maf') || player.classList.contains('don')) {
					++game.maf;
				} else if(player.classList.contains('maniac')) {
					++game.maniac;
				} else ++game.world;
			});
//console.log(game);
			if(game.world <= game.maf) {
				alert(this.L.winMaf);
				return false;
			}
			if(game.world <= game.maniac) {
				alert(this.L.winManiac);
				return false;
			}
			if(!game.maf && !game.maniac) {
				alert(this.L.winWorld);
				return false;
			}
			return true;
		}
	}).forEach(( [ k, v ] ) => {
		TM_MAF.prototype[k] = v;
	});

	window.onload = () => {
		new TM_MAF();
		//window.m = new TM_MAF( { lang: 'ru' } );
	}
})();
	</script>
	</head>
	<body class="vh"></body>
</html>
